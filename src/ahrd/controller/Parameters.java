package ahrd.controller;

import static ahrd.controller.Settings.getSettings;
import static ahrd.controller.Utils.randomMultipleOfOne;
import static ahrd.controller.Utils.randomMultipleOfTen;
import static ahrd.controller.Utils.randomSaveSubtract;
import static ahrd.controller.Utils.roundToNDecimalPlaces;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

/**
 * The following parameters are those subject to optimization. They are stored
 * wrapped in a distinct class from Settings in order to enable random
 * generation and scoring of these parameters.
 * 
 * @author Florian Boecker, Kathrin Klee, Asis Hallab
 */
public abstract class Parameters implements Cloneable, Comparable<Parameters> {
	
	protected Double tokenScoreBitScoreWeight;
	protected Double tokenScoreDatabaseScoreWeight;
	protected Double tokenScoreOverlapScoreWeight;

	protected Map<String, Map<String, String>> blastDbParameters = new HashMap<String, Map<String, String>>();
	/**
	 * If we test different settings in the parameter-space, remember the
	 * average evaluation-score (objective-function).
	 */
	protected Double avgEvaluationScore;
	/**
	 * If we test different settings in the parameter-space, remember the
	 * average Precision (PPV: Positive-Predictive-Value).
	 */
	protected Double avgPrecision;
	/**
	 * If we test different settings in the parameter-space, remember the
	 * average Recall (TPR: True-Positives-Rate).
	 */
	protected Double avgRecall;
	/**
	 * In order to increase hill-climbing during optimization, the last mutated
	 * parameter is remembered. So that the next neighbor can be generated by
	 * mutating the same parameter again -with some probability-, if and only
	 * if, the last mutation resulted in an increase of the average evaluation
	 * score.
	 */
	protected Integer lastMutatedParameter = null;
	/**
	 * In order to fine tune the genetic algorithm for training of parameters
	 * it can be useful to remember the origin of the parameter set in the previous 
	 * generation.  
	 */
	protected String origin;
	
	public abstract int numberOfNonDbParameters();
	
	public abstract Parameters randomParameters(List<String> sortedDistinctBlastDatabaseNames);
	
	public abstract Parameters neighbour(Double diffEvalScoreToLastEvaluatedParams);
	
	@Override
	public Parameters clone() {
		Parameters clone;
		try {
			clone = (Parameters) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace(System.err);
			clone = null;
		}
		return clone;
	}
		
	/**
	 * If the last optimization step was done with better performing parameters,
	 * randomly decide to mutate the same Parameter to generate a new Neighbor
	 * in Parameter-Space. By this simulated annealing walks more likely uphill
	 * in Parameter-Score-Space. The probability P('Mutate same Parameter') :=
	 * 0, if score was not increased, (exp(-(1-increase.score))+s)/(exp(0)+s)
	 * else
	 * 
	 * @param increaseInAvgEvaluationScore
	 *            - The difference in average evaluation scores between the
	 *            currently accepted parameters and the currently evaluated
	 *            ones.
	 * @return Double
	 */
	public static Double pMutateSameParameter(Double increaseInAvgEvaluationScore) {
		double p = 0.0;
		if (increaseInAvgEvaluationScore != null && increaseInAvgEvaluationScore > 0.0) {
			Double s = getSettings().getpMutateSameParameterScale();
			p = (Math.exp(-(1.0 - increaseInAvgEvaluationScore)) + s) / (Math.exp(0) + s);
		}
		return p;
	}

	public int parameterToMutateRandomIndex() {
		int randParamInd = 0;
		// How many Parameters can be mutated?
		int noOfParams = numberOfNonDbParameters() + 2 * getBlastDatabases().size();
		// Randomly choose a parameter to change:
		Random rand = Utils.random;
		randParamInd = rand.nextInt(noOfParams);
		return randParamInd;
	}

	public String randomBlastDatabaseName() {
		Random rand = Utils.random;
		int randBlastDbInd = rand.nextInt(getBlastDatabases().size());
		List<String> blastDbNamesList = new ArrayList<String>(
				getBlastDatabases());
		return blastDbNamesList.get(randBlastDbInd);
	}

	/**
	 * @param blastDatabaseName
	 */
	public void mutateBlastDatabaseWeight(String blastDatabaseName) {
		Long bdbw = getBlastDbWeight(blastDatabaseName).longValue();
		Long mutateBy = mutateBlastDatabaseWeightBy();
		if (randomSaveSubtract(bdbw, mutateBy))
			bdbw -= mutateBy;
		else
			bdbw += mutateBy;

		setBlastDbWeight(blastDatabaseName, bdbw.toString());
	}

	/**
	 * Returns 100 multiplied with the rounded up absolute of a random Gaussian
	 * distributed value with mean Settings.MUTATOR_MEAN and deviation
	 * Settings.MUTATOR_DEVIATION.
	 * 
	 * @Note: Only the <strong>absolute</strong> of the random Gaussian is
	 *        returned, as to subtract or add is decided elsewhere.
	 * 
	 * @return Long - The value to add or subtract from the Percentage to
	 *         mutate.
	 */
	public static long mutateBlastDatabaseWeightBy() {
		return new Double(Math.ceil(100.0 * mutatePercentageBy())).longValue();
	}
	
	/**
	 * @param blastDatabaseName
	 */
	public void mutateAnnotationScoreBitScoreWeight(String blastDatabaseName) {
		Double bsw = getAnnotationScoreBitScoreWeight(blastDatabaseName);
		Double mutateBy = mutatePercentageBy();
		if (randomSaveSubtract(bsw, mutateBy))
			bsw -= mutateBy;
		else
			bsw += mutateBy;
		setAnnotationScoreBitScoreWeight(blastDatabaseName, bsw.toString());
	}

	/**
	 * Normalizes the three weights appearing in the Token-Score-Formula, so
	 * they sum up to 1.0
	 * 
	 * High values (eg. 1.5) of the "mutator_mean" setting lead to TokenScoreWeight sums of 0.0.
	 * This problem likely exists in all branches using the mutateZeroToOne method introduced in commit 532f9c1.
	 * -> Needs to be avoided by resetting each of the three TokenScoreWeights to 1/3
	 */
	public void normalizeTokenScoreWeights() {
		double s = getTokenScoreBitScoreWeight()
				+ getTokenScoreDatabaseScoreWeight()
				+ getTokenScoreOverlapScoreWeight();
		if (s <= 0.0) {
			setTokenScoreBitScoreWeight(0.333);
			setTokenScoreDatabaseScoreWeight(0.333);
			setTokenScoreOverlapScoreWeight(0.333);
		} else {
			setTokenScoreBitScoreWeight(roundToNDecimalPlaces(
					getTokenScoreBitScoreWeight() / s, 4));
			setTokenScoreDatabaseScoreWeight(roundToNDecimalPlaces(
					getTokenScoreDatabaseScoreWeight() / s, 4));
			setTokenScoreOverlapScoreWeight(roundToNDecimalPlaces(
					getTokenScoreOverlapScoreWeight() / s, 4));
		}
	}

	/**
	 * Diminishes or increases Token-Score-Bit-Score-Weight by
	 * PERCENTAGE_MUTATOR_SEED and normalizes the three weights in the
	 * Token-Score-Formula.
	 */
	public void mutateTokenScoreBitScoreWeight() {
		setTokenScoreBitScoreWeight(mutateZeroToOne(getTokenScoreBitScoreWeight()));
		// normalize:
		normalizeTokenScoreWeights();
	}

	/**
	 * Diminishes or increases Token-Score-Database-Score-Weight by
	 * PERCENTAGE_MUTATOR_SEED and normalizes the three weights in the
	 * Token-Score-Formula.
	 */
	public void mutateTokenScoreDatabaseScoreWeight() {
		setTokenScoreDatabaseScoreWeight(mutateZeroToOne(getTokenScoreDatabaseScoreWeight()));
		// normalize:
		normalizeTokenScoreWeights();
	}

	/**
	 * Diminishes or increases Token-Score-Overlap-Score-Weight by
	 * PERCENTAGE_MUTATOR_SEED and normalizes the three weights in the
	 * Token-Score-Formula.
	 */
	public void mutateTokenScoreOverlapScoreWeight() {
		setTokenScoreOverlapScoreWeight(mutateZeroToOne(getTokenScoreOverlapScoreWeight()));
		// normalize:
		normalizeTokenScoreWeights();
	}
	
	/**
	 * Diminishes or increases a value between zero and one
	 */
	public static double mutateZeroToOne(double value) {
		double mutateBy = value*mutatePercentageBy();
		boolean up = Utils.random.nextBoolean();
		if (value <= 0.0) {
			up = true;
			mutateBy = 0.01*mutatePercentageBy();
		}
		if (value >= 1.0) {
			up = false;
		}
		if (up) {
			if (value + mutateBy > 1.0) {
				value = 1.0;
			} else {
				value = value + mutateBy;
			}
		} else {
			if (value - mutateBy < 0.0) {
				value = 0.0;
			} else {
				value = value - mutateBy;
			}
		}
		return(value);
	}

	/**
	 * Returns the absolute of a random Gaussian distributed value with mean
	 * Settings.MUTATOR_MEAN and deviation Settings.MUTATOR_DEVIATION.
	 * 
	 * @Note: Only the <strong>absolute</strong> of the random Gaussian is
	 *        returned, as to subtract or add is decided elsewhere.
	 * 
	 * @return Double - The value to add or subtract from the Percentage to
	 *         mutate.
	 */
	public static double mutatePercentageBy() {
		return Math.abs(Utils.random.nextGaussian()
				* getSettings().getMutatorDeviation()
				+ getSettings().getMutatorMean());
	}

	/**
	 * Creates an offspring with a random recombination of the current parameters and a given parameter set.
	 * 
	 * @NOTE: The three <em>Token-Score-Weights</em> are normalized to sum up to 1.
	 * 
	 * @param partner - The Parameters to recombine the current ones with 
	 * 
	 * @return The random offspring of the current and given Parameters  
	 */
	public abstract Parameters recombine(Parameters partner);

	@Override
	public abstract boolean equals(Object eql);

	@Override
	public abstract int hashCode();
	
	public abstract String buildHeaderForOutput(String separator);
	
	public abstract String formatForOutput(DecimalFormat frmt, String separator);
	
	/**
	* Compares the average evaluation score of the current Parameters with 
	* the average evaluation score of the specified parameters for order. 
	* Returns a negative integer, zero, or a positive integer as the average 
	* evaluation score of the current Parameters of these Parameters is less
    * than, equal to, or greater than the average evaluation Score of the 
    * specified Parameters.
    * 
    * In case different parameter sets have been evaluated to the exact same 
    * average score they can be further distinguished by the values of the 
    * parameters themselves.
    * */
	public int compareTo(Parameters other) {
		if (this.getAvgEvaluationScore() != null && other.getAvgEvaluationScore() != null){
			if (this.getAvgEvaluationScore() < other.getAvgEvaluationScore())
				return -1;
			if (this.getAvgEvaluationScore() > other.getAvgEvaluationScore())
				return 1;
			if (this.getTokenScoreBitScoreWeight() < other.getTokenScoreBitScoreWeight())
				return -1;
			if (this.getTokenScoreBitScoreWeight() > other.getTokenScoreBitScoreWeight())
				return 1;
			if (this.getTokenScoreDatabaseScoreWeight() < other.getTokenScoreDatabaseScoreWeight())
				return -1;
			if (this.getTokenScoreDatabaseScoreWeight() > other.getTokenScoreDatabaseScoreWeight())
				return 1;
			if (this.getTokenScoreOverlapScoreWeight() < other.getTokenScoreOverlapScoreWeight())
				return -1;
			if (this.getTokenScoreOverlapScoreWeight() > other.getTokenScoreOverlapScoreWeight())
				return 1;
			for (String blastDbName : getSettings().getSortedBlastDatabases()) {
				if (this.getAnnotationScoreBitScoreWeight(blastDbName) < other.getAnnotationScoreBitScoreWeight(blastDbName))
					return -1;
				if (this.getAnnotationScoreBitScoreWeight(blastDbName) > other.getAnnotationScoreBitScoreWeight(blastDbName))
					return 1;
				if (this.getBlastDbWeight(blastDbName) < other.getBlastDbWeight(blastDbName))
					return -1;
				if (this.getBlastDbWeight(blastDbName) > other.getBlastDbWeight(blastDbName))
					return 1;
			}
		}
		return 0;
	}
	
	/**
	 * @return Set<String> the names of the blast-databases used in the current
	 *         AHRD-Run.
	 */
	public Set<String> getBlastDatabases() {
		return getBlastDbParameters().keySet();
	}

	protected Map<String, String> getParametersOfBlastDb(String blastDbName) {
		Map<String, String> out = getBlastDbParameters().get(blastDbName);
		// Init new on first request:
		if (out == null) {
			out = new HashMap<String, String>();
			getBlastDbParameters().put(blastDbName, out);
		}
		return out;
	}

	public Integer getBlastDbWeight(String blastDatabaseName) {
		return Integer.parseInt(getParametersOfBlastDb(blastDatabaseName).get(
				Settings.BLAST_DB_WEIGHT_KEY));
	}

	public void setBlastDbWeight(String blastDatabaseName, String bdbw) {
		getParametersOfBlastDb(blastDatabaseName).put(
				Settings.BLAST_DB_WEIGHT_KEY, bdbw);
	}

	public Double getAnnotationScoreBitScoreWeight(String blastDatabaseName) {
		return Double.parseDouble(getParametersOfBlastDb(blastDatabaseName)
				.get(Settings.ANNOTATION_SCORE_BIT_SCORE_WEIGHT));
	}

	public void setAnnotationScoreBitScoreWeight(String blastDatabaseName,
			String dsbsw) {
		getParametersOfBlastDb(blastDatabaseName).put(
				Settings.ANNOTATION_SCORE_BIT_SCORE_WEIGHT, dsbsw);
	}

	public Double getTokenScoreBitScoreWeight() {
		return tokenScoreBitScoreWeight;
	}

	public void setTokenScoreBitScoreWeight(Double tokenScoreBitScoreWeight) {
		this.tokenScoreBitScoreWeight = tokenScoreBitScoreWeight;
	}

	public Double getTokenScoreDatabaseScoreWeight() {
		return tokenScoreDatabaseScoreWeight;
	}

	public void setTokenScoreDatabaseScoreWeight(
			Double tokenScoreDatabaseScoreWeight) {
		this.tokenScoreDatabaseScoreWeight = tokenScoreDatabaseScoreWeight;
	}

	public Double getTokenScoreOverlapScoreWeight() {
		return tokenScoreOverlapScoreWeight;
	}

	public void setTokenScoreOverlapScoreWeight(
			Double tokenScoreOverlapScoreWeight) {
		this.tokenScoreOverlapScoreWeight = tokenScoreOverlapScoreWeight;
	}

	public Double getAvgEvaluationScore() {
		return avgEvaluationScore;
	}

	public void setAvgEvaluationScore(Double avgEvaluationScore) {
		this.avgEvaluationScore = avgEvaluationScore;
	}

	public Map<String, Map<String, String>> getBlastDbParameters() {
		return blastDbParameters;
	}

	public Double getAvgPrecision() {
		return avgPrecision;
	}

	public void setAvgPrecision(Double avgPrecision) {
		this.avgPrecision = avgPrecision;
	}
	
	public Double getAvgRecall() {
		return avgRecall;
	}

	public void setAvgRecall(Double avgRecall) {
		this.avgRecall = avgRecall;
	}

	public Integer getLastMutatedParameter() {
		return lastMutatedParameter;
	}

	public void setLastMutatedParameter(Integer lastMutatedParameter) {
		this.lastMutatedParameter = lastMutatedParameter;
	}
	
	public String getOrigin() {
		return origin;
	}

	public void setOrigin(String origin) {
		this.origin = origin;
	}

}